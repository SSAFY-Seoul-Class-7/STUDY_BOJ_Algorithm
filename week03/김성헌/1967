import java.io.*;
import java.util.*;
public class bj_1967 {
    private static int n,result, end;
    private static List<Node>[] list;
    private static boolean[] visited;
    static class Node{
        int to;
        int cost;

        public Node(int to,int cost){
            this.to=to;
            this.cost=cost;
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        n=Integer.parseInt(br.readLine());

        if(n==1){
            System.out.println(0);
            return;
        }
        list=new ArrayList[n+1];


        for (int i = 1; i  <=n ; i++) {
            list[i]= new ArrayList<>();
        }

        for (int i = 0; i < n-1; i++) {
            st=new StringTokenizer(br.readLine());
            int from=Integer.parseInt(st.nextToken());
            int to=Integer.parseInt(st.nextToken());
            int cost=Integer.parseInt(st.nextToken());
            list[from].add(new Node(to,cost));
            list[to].add(new Node(from,cost));
        }


        int sum=0;
        visited=new boolean[n+1];
        visited[1]=true;
        dfs(1,0); // 처음으로 가장 먼노드 찾기

        result=0;
        visited=new boolean[n+1];
        visited[end]=true;
        dfs(end,0);
        sum+=result;

        System.out.println(sum);

    }
    private static void dfs(int curr, int dist){

        if(dist>result){
            result=dist;
            end=curr; // 노드 갱신
        }

        for (Node next:list[curr]){
            if(!visited[next.to]){
                visited[next.to]=true;
                dfs(next.to, dist+ next.cost);
            }
        }
    }
}
