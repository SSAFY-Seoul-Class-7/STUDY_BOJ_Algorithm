import java.io.*;
import java.util.*;
public class Main {
    static class Edge implements Comparable<Edge>{
        int to,cost;
        public Edge(int to,int cost){

            this.to=to;
            this.cost=cost;
        }
        @Override
        public int compareTo(Edge o) {
            return this.cost-o.cost;
        }
    }
    private static int n,m,x;
    private static List<Edge>[] list,reverse;
    private static int[] dist,distReverse;

    public static void main(String[] args) throws IOException {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st=new StringTokenizer(br.readLine());

        n=Integer.parseInt(st.nextToken());
        m=Integer.parseInt(st.nextToken());
        x=Integer.parseInt(st.nextToken());

        list=new ArrayList[n+1];
        reverse=new ArrayList[n+1];
        dist=new int[n+1];
        distReverse=new int[n+1];

        for (int i = 0; i <n+1 ; i++) {
            list[i]=new ArrayList<>();
            reverse[i]=new ArrayList<>();
        }

        for (int i = 0; i < m; i++) {
            st=new StringTokenizer(br.readLine());

            int from=Integer.parseInt(st.nextToken());
            int to=Integer.parseInt(st.nextToken());
            int cost=Integer.parseInt(st.nextToken());

            list[from].add(new Edge(to,cost));
            reverse[to].add(new Edge(from,cost));
        }

        dij(list,dist);
        dij(reverse,distReverse);

        int max=0;

        for (int i = 1; i <=n; i++) {
            int num= dist[i]+distReverse[i];

            max=Math.max(num,max);
        }
        System.out.println(max);
//
//        for (int i = 0; i < n; i++) {
//            for (int j = 0; j < list[i].size(); j++) {
//                System.out.println(list[i].get(j).to+" "+list[i].get(j).cost);
//            }
//        }
    }
    private static void dij(List<Edge>[] map, int[] dist){
        Arrays.fill(dist,Integer.MAX_VALUE);
        PriorityQueue<Edge> pq=new PriorityQueue<>();

        pq.add(new Edge(x,0));
        dist[x]=0;

        while(!pq.isEmpty()){
            Edge curr =pq.poll();
            if(dist[curr.to]<curr.cost) continue;
            for (int i = 0; i < map[curr.to].size(); i++) {
                Edge edge=map[curr.to].get(i);
                int next=edge.to;
                int nextCost= curr.cost+edge.cost;

                if(nextCost<dist[next]){
                    pq.add(new Edge(next,nextCost));
                    dist[next]=nextCost;
                }
            }

        }
    }
}
